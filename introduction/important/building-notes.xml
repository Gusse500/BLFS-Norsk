<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE sect1 PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
   "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
  <!ENTITY % general-entities SYSTEM "../../general.ent">
  %general-entities;
]>

<sect1 id="unpacking">
  <?dbhtml filename="notes-on-building.html"?>


  <title>Merknader om å Bygge Programvare</title>

  <para>De personene som har bygget et LFS system kan være klar over
  de generelle prinsippene for nedlasting og utpakking av programvare. Noe
  av denne informasjonen gjentas her for de som er nye i byggingen
  av egen programvare.</para>

  <para>Hvert sett med installasjonsinstruksjoner inneholder en URL som du
  kan laste ned pakken fra. Oppdateringene; lagres imidlertid på LFS
  servere og er tilgjengelige via HTTP. Disse er referert til etter behov i
  installasjonsinstruksjonene.</para>

  <para>Selv om du kan beholde kildefilene hvor som du vil, antar vi at
  du har pakket ut pakken og endret til mappen opprettet av
  utpakkingsprosessen ('build' mappen). Vi antar også at du har
  dekomprimerte eventuelle nødvendige oppdateringer og de er i katalogen umiddelbart
  over 'build' mappen.</para>

  <para>Vi kan ikke understreke sterkt nok at du bør ta utgangspunkt i et
  <emphasis>rent kildetre</emphasis> hver gang. Dette betyr at hvis
  du har hatt en feil under konfigurasjon eller kompilering, er det vanligvis
  best å slette kildetreet og
  pakke den ut på nytt <emphasis>før</emphasis> prøver igjen. Dette gjelder åpenbart
  ikke hvis du er en avansert bruker som er vant til å hacke
  <filename>Makefile</filename> filer og C kode, men hvis du er i tvil, start fra et
  rent tre.</para>

  <sect2>
    <title>Bygge Programvare som en Uprivilegert (ikke-root) Bruker</title>

    <para>Den gylne regelen for Unix System Administrasjon er å bruke dine
    superkrefter bare når det er nødvendig. Derfor anbefaler BLFS at du
    bygger programvare som en uprivilegert bruker og bare bli
    <systemitem class='username'>root</systemitem> bruker når du installerer
    programvare. Denne filosofien følges i alle pakkene i denne boken.
    Med mindre annet er spesifisert, skal alle instruksjoner utføres som en
    uprivilegert bruker. Boken vil gi deg råd om instruksjoner du trenger
    <systemitem class='username'>root</systemitem> privilegier.</para>

  </sect2>

  <sect2>
    <title>Pakke ut Programvaren</title>

    <para>Hvis en fil er i <filename class='extension'>.tar</filename> formatet
    og komprimert, pakkes den ut ved å kjøre en av følgende
    kommandoer:</para>

<screen><userinput>tar -xvf filename.tar.gz
tar -xvf filename.tgz
tar -xvf filename.tar.Z
tar -xvf filename.tar.bz2</userinput></screen>

    <note>
      <para>Du kan utelate å bruke <option>v</option> parameteren i kommandoene
      vist over og under hvis du ønsker å undertrykke den detaljerte listen over alle
      filene i arkivet etter hvert som de pakkes ut. Dette kan bidra til å øke hastigheten
      på utpakkingen samt gjøre eventuelle feil som oppstår under utpakkingen
      mer tydelig for deg.</para>
    </note>

    <para>Du kan også bruke en litt annen metode:</para>

<screen><userinput>bzcat filename.tar.bz2 | tar -xv</userinput></screen>

    <para>Til slutt må du noen ganger være i stand til å pakke ut oppdateringer som
    vanligvis ikke er i <filename class='extension'>.tar</filename> formatet.
    Beste måten å gjøre dette på er å kopiere oppdateringsfilen til forelderen til "build"
    mappen og kjør deretter en av følgende kommandoer avhengig av om
    filen er en <filename class='extension'>.gz</filename> eller <filename
    class='extension'>.bz2</filename> fil:</para>

<screen><userinput>gunzip -v patchname.gz
bunzip2 -v patchname.bz2</userinput></screen>

  </sect2>

  <sect2>
    <title>Verifiserer Filintegritet</title>

    <para>Generelt, for å bekrefte at den nedlastede filen er fullstendig,
    mange pakkevedlikeholdere distribuerer også md5sum av filene. For å bekrefte
    md5sum av de nedlastede filene, last ned både filen og
    tilsvarende md5sum fil til samme katalog (helst fra en annen
    nettplasseringer), og (forutsatt <filename>file.md5sum</filename> er
    md5sum filen lastet ned) kjør følgende kommando:</para>

<screen><userinput>md5sum -c file.md5sum</userinput></screen>

    <para>Hvis det er noen feil, vil de bli rapportert. Merk at BLFS
    boken også inkluderer md5sum for alle kildefilene. For å bruke BLFS
    medfølgende md5sum, kan du opprette en <filename>file.md5sum</filename> (plasser
    md5sum dataene og det nøyaktige navnet på den nedlastede filen på samme
    linje i en fil, atskilt med mellomrom) og kjør kommandoen vist ovenfor.
    Alternativt kan du bare kjøre kommandoen vist nedenfor og sammenligne utdataene
    til md5sum dataene vist i BLFS boken.</para>

<screen><userinput>md5sum <replaceable>&lt;name_of_downloaded_file&gt;</replaceable></userinput></screen>

    <para>MD5 er ikke kryptografisk sikker, så md5summene er kun
    for å oppdage uønskede endringer i filinnholdet.
    For eksempel en feil eller avkorting som ble introdusert under nettverksoverføring, eller
    en <quote>stealth</quote> oppdatering til pakken fra oppstrøms
    (oppdaterer innholdet i en utgitt tarball i stedet for å lage en ny
    slipp riktig).</para>

    <para>Det er ingen måte å være <quote>100%</quote> sikker
    på ektheten til kildefilene. Forutsatt at oppstrøms styrer
    nettstedet deres riktig (den private nøkkelen lekkes ikke og domenet ikke er
    kapret), og tillitsankrene er satt opp riktig ved hjelp av
    <xref linkend="make-ca"/> på BLFS systemet kan vi med rimelighet stole på
    nedlastings URL-er til oppstrøms offisielle nettsted
    <emphasis role="bold">med https protokoll</emphasis>.  Noter at
    selve BLFS boken er publisert på en nettside med https, så du bør
    allerede ha litt tillit til https protokollen, ellers ville du ikke stole på
    bokens innhold.</para>

    <para>Hvis pakken er lastet ned fra et uoffisielt sted (for
    eksempel et lokalt speil), kontrollsummer generert av kryptografisk sikre
    sammendragsalgoritmer (for eksempel SHA256) kan brukes til å bekrefte
    ektheten av pakken. Last ned kontrollsumfilen fra oppstrøms
    <emphasis role="bold">offisielle</emphasis> nettsted (eller et sted
    <emphasis role="bold">du kan stole på</emphasis>) og sammenligne
    sjekksummen av pakken fra uoffisiell plassering av den. For eksempel,
    SHA256 sjekksummen kan sjekkes med kommandoen:</para>

    <note>
      <para>Hvis kontrollsummen og pakken er lastet ned fra samme
      uklarerte plassering, vil du ikke oppnå sikkerhetsforbedring ved å bekrefte
      pakken med sjekksummen. Angriperen kan forfalske kontrollsummen
      i tillegg til å kompromittere selve pakken.</para>
    </note>

<screen><userinput>sha256sum -c <replaceable>file</replaceable>.sha256sum</userinput></screen>

    <para>Hvis <xref linkend="gnupg2"/> er installert, kan du også bekrefte
    ektheten til pakken med en GPG signatur. Importer oppstrøms GPG
    offentlig nøkkel med:</para>

<screen><userinput>gpg --recv-key <replaceable>keyID</replaceable></userinput></screen>

    <para><replaceable>keyID</replaceable> bør erstattes med nøkkel ID
    fra et sted <emphasis role="bold">du kan stole på</emphasis> (for
    eksempel, kopier den fra oppstrøms offisielle nettside ved å bruke https). Nå
    kan du verifisere signaturen med:</para>

<screen><userinput>gpg --recv-key <replaceable>file</replaceable>.sig <replaceable>file</replaceable></userinput></screen>

    <para>Fordelen med <application>GnuPG</application> signaturen er,
    at når du har importert en offentlig nøkkel som du kan stole på, kan du laste ned
    både pakken og dens signatur fra samme uoffisielle sted og
    verifiser dem med den offentlige nøkkelen. Så du trenger ikke å koble til
    offisielle oppstrømsnettsted for å hente en kontrollsum for hver nye utgivelse.
    Du trenger bare å oppdatere den offentlige nøkkelen hvis den er utløpt eller tilbakekalt.
    </para>

  </sect2>

  <sect2>
    <title>Opprette Loggfiler Under Installasjonen</title>

    <para>For større pakker er det praktisk å lage loggfiler i stedet for
    å stirre på skjermen i håp om å fange en bestemt feil eller advarsel. Loggfiler
    er også nyttige for feilsøking og journalføring. Følgende
    kommando lar deg lage en installasjonslogg. Erstatt
    <replaceable>&lt;command&gt;</replaceable> med kommandoen du har tenkt å utføre.</para>

<screen><userinput>( <replaceable>&lt;command&gt;</replaceable> 2&gt;&amp;1 | tee compile.log &amp;&amp; exit $PIPESTATUS )</userinput></screen>

    <para><option>2&gt;&amp;1</option> omdirigerer feilmeldinger til den samme
    plassering som standard utdata. <command>tee</command> kommandoen tillater
    visning av utdata mens du logger resultatene til en fil. Parentesene
    rundt kommandoen kjører hele kommandoen i et underskall og til slutt
    <command>exit $PIPESTATUS</command> kommando sikrer resultatet av
    <replaceable>&lt;command&gt;</replaceable> returneres som resultatet og ikke
    resultatet av <command>tee</command> kommandoen.</para>

  </sect2>

  <sect2 id="parallel-builds" xreflabel="Using Multiple Processors">
    <title>Bruk av Flere Prosessorer</title>

    <para>For mange moderne systemer med flere prosessorer (eller kjerner) kan
    kompileringstiden for en pakke reduseres ved å utføre en "parallell
    make" ved enten å sette en miljøvariabel eller fortelle make programmet
    hvor mange prosessorer som er tilgjengelige. For eksempel kan en Core2Duo støtte to
    samtidige prosesser med: </para>

    <screen><userinput>export MAKEFLAGS='-j2'</userinput></screen>

    <para>eller bare bygge med:</para>

    <screen><userinput>make -j2</userinput></screen>

    <para>
      Hvis du har brukt den valgfrie <command>sed</command> når du bygget
      <application>ninja</application> i LFS, kan du bruke:
    </para>

    <screen><userinput>export NINJAJOBS=2</userinput></screen>

    <para>
      når en pakke bruker <command>ninja</command>, eller bare:
    </para>

    <screen><userinput>ninja -j2</userinput></screen>

    <para>
      men for ninja er standard antall jobber &lt;N&gt;+2, hvor &lt;N&gt;
      er antall tilgjengelige prosessorer, slik at bruk av kommandoene ovenfor
      er snarere for å begrense antall jobber (se nedenfor for hvorfor dette kan
      være nødvendig).
    </para>

    <para>Generelt bør antallet prosesser ikke overstige antallet
    kjerner støttet av CPU. For å liste opp prosessorene på ditt
    system, kjør: <userinput>grep processor /proc/cpuinfo</userinput>.
    </para>

    <para>I noen tilfeller kan bruk av flere prosesser resultere i en "løps"
    tilstand hvor suksessen til bygget avhenger av rekkefølgen til
    kommandoer som kjøres av <command>make</command> programmet. For eksempel, hvis en
    kjørbar trenger fil A og fil B, og prøver å koble programmet før
    en av de avhengige komponentene er tilgjengelig vil resultere i en feil.
    Denne tilstanden oppstår vanligvis fordi oppstrømsutvikleren ikke har
    angitt alle forutsetningene riktig som trengs for å oppnå et trinn i
    Makefile.</para>

    <para>Hvis dette skjer, er den beste måten å fortsette på å gå tilbake til en
    enkelt prosessor bygg. Legg til '-j1' til en make kommando vil overstyre
    den lignende innstillingen i <envar>MAKEFLAGS</envar>
    miljøvariabel.</para>

    <note><para>Når du kjører pakketestene eller installasjonsdelen av
    pakkebyggingsprosessen, anbefaler vi ikke å bruke et alternativ som er større enn
    '-j1' med mindre annet er spesifisert. Installasjonsprosedyrer eller kontroller
    har ikke blitt validert ved hjelp av parallelle prosedyrer og kan mislykkes med problemer
    som er vanskelige å feilsøke.</para></note>

    <important>
      <para>
        Et annet problem kan oppstå med moderne CPUer, som har mange kjerner.
        Hver påbegynt jobb bruker minne, og hvis summen av det nødvendige
        minnet for hver jobb overskrider tilgjengelig minne, kan du støte på
        enten et OOM kjerneavbrudd (tom minne) eller intens bytting
        som vil bremse byggingen utover rimelige grenser.
      </para>

      <para>
        Noen kompilasjoner med <command>g++</command> kan bruke opptil 2,5 GB
        minne, så for å være sikker bør du begrense antall jobber
        til (Totalt minne i GB)/2,5, i det minste for store pakker som LLVM,
        WebKitGtk, QtWebEngine eller libreoffice.
      </para>
    </important>
  </sect2>

  <sect2 id="automating-builds" xreflabel="Automated Building Procedures">
    <title>Automatiserte Byggeprosedyrer</title>

    <para>Det er tider når automatisering av byggingen av en pakke kan være
    praktisk. Alle har sine egne grunner til å ønske å automatisere byggingen,
    og alle gjør det på sin egen måte. Å opprette
    <filename>Makefile</filename>, <application>Bash</application> skripter,
    <application>Perl</application> skript eller bare en liste over kommandoer som brukes
    til å klippe og lime er bare noen av metodene du kan bruke for å automatisere
    byggingen av BLFS pakker. Detaljert hvordan og eksempler på de mange
    måter du kan automatisere byggingen av pakker på er utenfor rammen av denne
    seksjonen. Denne delen vil vise deg bruk av filomdirigering og
    <command>ja</command> kommandoer for å gi ideer om hvordan du kan automatisere
    byggene dine.</para>

    <bridgehead renderas="sect3">Filomadressering for å Automatisere Inndata</bridgehead>

    <para>Du vil finne tidspunkter gjennom hele BLFS reisen din at du kommer
    over en pakke som har en kommando som ber deg om informasjon. Denne
    informasjon kan være konfigurasjonsdetaljer, en mappebane eller et svar
    til en lisensavtale. Dette kan by på en utfordring for å automatisere
    byggingen av den pakken. Noen ganger vil du bli bedt om annen
    informasjon i en rekke spørsmål. En metode for å automatisere denne typen
    scenario krever å legge de ønskede svarene i en fil og bruke
    omdirigering slik at programmet bruker dataene i filen som svar på
    spørsmålene.</para>

    <para>Å bygge <application>CUPS</application> pakken er et bra
    eksempel på hvordan omdirigering av en fil som inndata til ledetekster kan hjelpe deg med å automatisere
    byggingen. Hvis du kjører testpakken, blir du bedt om å svare på en serie
    spørsmål om hvilken type test som skal kjøres og om du har noen
    hjelpeprogrammer testen kan bruke. Du kan lage en fil med dine
    svar, ett svar per linje, og bruk en kommando som ligner på
    den vist nedenfor for å automatisere kjøringen av testpakken:</para>

<screen><userinput>make check &lt; ../cups-1.1.23-testsuite_parms</userinput></screen>

    <para>Dette gjør effektivt at testpakken bruker svarene i filen
    som innspill til spørsmålene. Av og til kan du ende opp med å gjøre litt
    prøving og feiling for å bestemme det nøyaktige formatet på inndatafilen for noen
    ting, men når du har funnet ut og dokumentert, kan du bruke dette til å automatisere
    byggingen av pakken.</para>

    <bridgehead renderas="sect3">Ved hjelp av <command>yes</command> for å Automatisere
    Inndata</bridgehead>

    <para>Noen ganger trenger du bare å gi ett svar, eller gi
    samme svar på mange spørsmål. For disse tilfellene fungerer
    <command>yes</command> kommandoen veldig bra.
    <command>yes</command> kommandoen kan brukes til å gi et svar (det samme
    ett) til ett eller flere forekomster av spørsmål. Den kan brukes til å simulere
    å trykke på <keycap>Enter</keycap> tasten, skrive inn
    <keycap>Y</keycap> tasten eller skrive inn en tekststreng. Kanskje den enkleste
    måten er å vise bruken på er i et eksempel.</para>

    <para>Først lager du et kort <application>Bash</application> skript ved å
    skrive inn følgende kommandoer:</para>

<screen><userinput>cat &gt; blfs-yes-test1 &lt;&lt; "EOF"
<literal>#!/bin/bash

echo -n -e "\n\nPlease type something (or nothing) and press Enter ---> "

read A_STRING

if test "$A_STRING" = ""; then A_STRING="Just the Enter key was pressed"
else A_STRING="You entered '$A_STRING'"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test1</userinput></screen>

    <para>Kjør nå skriptet ved å utstede <command>./blfs-yes-test1</command> fra
    kommandolinjen. Den vil vente på et svar, som kan være hva som helst (eller
    ingenting) etterfulgt av <keycap>Enter</keycap> tasten. Etter å ha skrevet inn
    noe, vil resultatet bli ekko til skjermen. Bruk nå
    <command>yes</command> kommandoen for å automatisere inntasting av en
    respons:</para>

<screen><userinput>yes | ./blfs-yes-test1</userinput></screen>

    <para>Legg merke til videreledingen av <command>yes</command> til skriptet
    resulterer i at <keycap>y</keycap> blir overført til skriptet. Prøv nå med en
    tekststreng:</para>

<screen><userinput>yes 'This is some text' | ./blfs-yes-test1</userinput></screen>

    <para>Den nøyaktige strengen ble brukt som respons på skriptet. Endelig,
    prøv det med en tom (null) streng:</para>

<screen><userinput>yes '' | ./blfs-yes-test1</userinput></screen>

    <para>Legg merke til at dette resulterer i at du bare videreleder pressingen av
    <keycap>Enter</keycap> tasten til skriptet. Dette er nyttig for når
    standardsvar på ledeteksten er tilstrekkelig. Denne syntaksen brukes i
    <xref linkend="net-tools-automate-example"/> instruksjoner for å godta alle
    standardsvarene til de mange ledetekstene under konfigurasjonstrinnet. Du kan nå
    fjerne testskriptet om ønskelig.</para>

    <bridgehead renderas="sect3">Filomadressering for å Automatisere Utdata</bridgehead>

    <para>For å automatisere byggingen av noen pakker, spesielt de
    som krever at du leser en lisensavtale en side om gangen, krever
    å bruke en metode som unngår å måtte trykke på en tast for å vise hver side.
    Omdirigere utdataene til en fil kan brukes i disse tilfellene for å hjelpe
    med automatiseringen. Den forrige delen på denne siden berørte opprettelse
    av loggfiler for byggeutdataen. Omdirigeringsmetoden vist der brukte
    <command>tee</command> kommandoen for å omdirigere utdata til en fil men også
    vise utdataene på skjermen. Her vil utdataen kun sendes til
     en fil.</para>

    <para>Igjen, den enkleste måten å demonstrere teknikken på er å vise et
    eksempel. Utfør først kommandoen:</para>

<screen><userinput>ls -l /usr/bin | more</userinput></screen>

    <para>Selvfølgelig må du se utdataene en side om gangen
    fordi <command>more</command> filteret ble brukt. Prøv nå den samme
    kommandoen, men denne gangen omdirigerer utdataene til en fil. Den spesielle filen
    <filename>/dev/null</filename> kan brukes i stedet for filnavnet som vises,
    men du vil ikke ha noen loggfil å undersøke:</para>

<screen><userinput>ls -l /usr/bin | more &gt; redirect_test.log 2&gt;&amp;1</userinput></screen>

    <para>Legg merke til at denne gangen kom kommandoen umiddelbart tilbake til skallets
    ledetekst uten å måtte bla gjennom utdataene. Du kan nå fjerne
    loggfilen.</para>

    <para>Det siste eksemplet vil bruke <command>yes</command> kommandoen i
    kombinasjon med utdataomdirigering for å omgå å måtte bla gjennom
    utdataen og deretter gi en <keycap>y</keycap> til en spørring. Denne teknikken
    kan brukes i tilfeller der du ellers måtte bla gjennom
    utdata fra en fil (for eksempel en lisensavtale) og svare deretter på
    spørsmål om <quote>do you accept the above?</quote>. For dette eksempelet,
    et annen kort <application>Bash</application> skript kreves:</para>

<screen><userinput>cat &gt; blfs-yes-test2 &lt;&lt; "EOF"
<literal>#!/bin/bash

ls -l /usr/bin | more

echo -n -e "\n\nDid you enjoy reading this? (y,n) "

read A_STRING

if test "$A_STRING" = "y"; then A_STRING="You entered the 'y' key"
else A_STRING="You did NOT enter the 'y' key"
fi

echo -e "\n\n$A_STRING\n\n"</literal>
EOF
chmod 755 blfs-yes-test2</userinput></screen>

    <para>Dette skriptet kan brukes til å simulere et program som krever at du
    leser en lisensavtale, og svarer deretter på riktig måte for å godta
    avtalen før programmet vil installere noe. Kjør først skriptet
    uten automatiseringsteknikker ved å utstede
    <command>./blfs-yes-test2</command>.</para>

    <para>Utfør nå følgende kommando som bruker to automatiseringsteknikker,
    gjøre det egnet for bruk i et automatisert byggeskript:</para>

<screen><userinput>yes | ./blfs-yes-test2 &gt; blfs-yes-test2.log 2&gt;&amp;1</userinput></screen>

    <para>Hvis ønskelig, utsted <command>tail blfs-yes-test2.log</command> å se
    slutten av den sidesøkte utdataen, og bekreftelse på at <keycap>y</keycap> ble
    sendt videre til skriptet. Når du er overbevist om at den fungerer som den skal,
    kan du fjerne skriptet og loggfilen.</para>

    <para>Til slutt, husk at det er mange måter å automatisere og/eller
    skripte byggekommandoene. Det er ikke en eneste <quote>riktig</quote> måte
    å gjøre det på. Det er bare fantasien din som setter grenser.</para>

  </sect2>

  <sect2>
    <title>Avhengigheter</title>

    <para>For hver pakke som er beskrevet, viser BLFS de kjente avhengighetene.
    Disse er oppført under flere overskrifter, hvis betydning er som følger:</para>

    <itemizedlist>
      <listitem>
        <para><emphasis>Påkrevd</emphasis> betyr at målpakken
        ikke kan bygges riktig uten at avhengigheten først er
        installert.</para>
      </listitem>
      <listitem>
        <para><emphasis>Anbefalt</emphasis> betyr at BLFS sterkt
        foreslår at denne pakken installeres først for en ren og problemfri
        bygging, som ikke vil ha problemer verken under byggeprosessen eller ved
        kjøretid. Instruksjonene i boken forutsetter at disse pakkene er
        installert. Noen endringer eller løsninger kan være nødvendige hvis disse
        pakkene ikke er installert.</para>
      </listitem>
      <listitem>
        <para><emphasis>Valgfri</emphasis> betyr at denne pakken kan bli
        installert for ekstra funksjonalitet. Ofte vil BLFS beskrive
        avhengigheten for å forklare den ekstra funksjonaliteten resultatet gir .</para>
      </listitem>
    </itemizedlist>

  </sect2>

  <sect2 id="package_updates">
    <title>Bruke de Nyeste Pakkekildene</title>

    <para>Noen ganger kan du støte på en situasjon i boken når en pakke
    ikke vil bygge eller fungere skikkelig. Selv om redaktørene prøver å sikre
    at hver pakke i boken bygger og fungerer som den skal, noen ganger har
    pakken blitt oversett eller ble ikke testet med denne versjonen
    av BLFS.</para>

    <para>Hvis du oppdager at en pakke ikke vil bygge eller fungere som den skal,
    bør du se om det finnes en mer oppdatert versjon av pakken. Typisk betyr
    dette at du går til vedlikeholderens nettsted og laster ned den nyeste
    tarballen og forsøke å bygge pakken. Hvis du ikke kan bestemme
    vedlikeholderens nettsted ved å se på nedlastingsadressene, bruk Google og spør
    etter pakkens navn. Skriv for eksempel i Google-søkefeltet:
    'pakkenavn nedlasting' (utelat anførselstegn) eller noe lignende. Noen ganger
    å skrive: 'pakkenavn hjemmeside' vil resultere i at du finner
    vedlikeholderens nettsted.</para>

  </sect2>

  <sect2 id="stripping">
    <title>Strippe En Gang Til</title>

    <para>
      I LFS, stripping av feilsøkingssymboler og unødvendige symboltabell
      oppføringer ble diskutert et par ganger. Når du bygger BLFS pakker,
      er det generelt ingen spesielle instruksjoner som diskuterer stripping
      en gang til. Stripping kan gjøres mens du installerer en pakke, eller
      etterpå.
    </para>

    <bridgehead renderas="sect3" id="stripping-install">Stripping mens du Installerer en Pakke</bridgehead>

    <para>
      Det er flere måter å strippe kjørbare filer installert av en
      pakke. Det avhenger av byggesystemet som brukes (se nedenfor <link
        linkend="buildsystems">avsnittet om byggesystemer</link>),
      så bare noen
      generelle forhold kan listes opp her:
    </para>

    <note>
      <para>
        Følgende metoder ved hjelp av funksjonen til et byggesystem
        (autoverktøy, meson eller cmake) vil ikke strippe statiske biblioteker hvis noen
        er installert. Heldigvis er det ikke for mange statiske biblioteker
        i BLFS, og et statisk bibliotek kan alltid strippes trygt med å
        kjøre <command>strip --strip-unneeded</command> på den manuelt.
      </para>
    </note>

    <itemizedlist>
      <listitem>
        <para>
          Pakkene som bruker autoverktøy har vanligvis et
          <parameter>install-strip</parameter> mål i deres genererte
          <filename>Makefile</filename> filer. Så installere strippede
          kjørbare er bare et spørsmål om å bruke
          <command>make install-strip</command> i stedet for
          <command>make install</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          Pakkene som bruker meson byggesystemet kan godta
          <parameter>-Dstrip=true</parameter> når du kjører
          <command>meson</command>.  Hvis du har glemt å legge til dette alternativet
          ved kjøring av <command>meson</command>, kan du også kjøre
          <command>meson install --strip</command> i stedet for
          <command>ninja install</command>.
        </para>
      </listitem>
      <listitem>
        <para>
          <command>cmake</command> genererer
          <parameter>install/strip</parameter> mål for både
          <parameter>Unix Makefiles</parameter> og
          <parameter>Ninja</parameter> generatorer (standard er
          <parameter>Unix Makefiles</parameter> på linux). Så bare kjør
          <command>make install/strip</command> eller
          <command>ninja install/strip</command> i stedet for
          <command>install</command> motparter.
        </para>
      </listitem>
      <listitem>
        <para>
          Å strippe (eller ikke generere) feilsøkingssymboler kan også
          oppnås ved å strippe
          <parameter>-g&lt;noe&gt;</parameter> alternativer
          i C/C++-anrop. Hvordan du gjør det er veldig spesifikt for hver enkelt
          pakke. Og den stripper ikke unødvendige symboltabelloppføringer.
          Så det vil ikke bli forklart i detalj her. Se også nedenfor
          avsnittene om optimalisering.
        </para>
      </listitem>
    </itemizedlist>

    <bridgehead renderas="sect3" id="stripping-installed">Stripping av Installerte Kjørbare filer</bridgehead>

    <para>
      <command>strip</command> verktøyet endrer filer på plass, noe som kan
      bryte noe ved å bruke det hvis det er lastet inn i minnet. Merk at hvis en fil er
      i bruk, men nettopp strippet fra disken (dvs. ikke overskrevet eller
      modifisert), er dette ikke et problem siden kjernen kan bruke
      <quote>slettede</quote> filer. Se på <filename>/proc/*/maps</filename>
      og det er sannsynlig at du vil se noen <emphasis>(slettede)</emphasis>
      oppføringer. <command>mv</command> fjerner bare målfilen fra
      mappen, men berører ikke innholdet, slik at den tilfredsstiller
      betingelsen for at kjernen skal bruke den gamle (slettede) filen. Skriptet nedenfor
      er bare et eksempel.
       Den skal kjøres som &root; bruker:
    </para>

<screen><userinput>cat &gt; /usr/sbin/strip-all.sh &lt;&lt; "EOF"
<literal>#!/usr/bin/bash

if [ $EUID -ne 0 ]; then
  echo "Need to be root"
  exit 1
fi

{ find /usr/lib -type f -name '*.so*' ! -name '*dbg'
  find /usr/lib -type f -name '*.a'
  find /usr/{bin,sbin,libexec} -type f
} |  while read file; do
       if ! readelf -h $file >/dev/null 2>&amp;1; then continue; fi
       if file $file | grep --quiet --invert-match 'not stripped'; then continue; fi

       cp --preserve $file    ${file}.tmp
       strip --strip-unneeded ${file}.tmp
       mv ${file}.tmp $file
     done</literal>
EOF
chmod 744 /usr/sbin/strip-all.sh</userinput></screen>

    <para>
      Hvis du installerer programmer i andre mapper som f.eks <filename
      class="directory">/opt</filename> eller <filename
      class="directory">/usr/local</filename>, kan det være lurt å strippe filene
      der også. Bare legg til andre mapper for å skanne i den sammensatte
      <command>find</command> kommandoen mellom krøllparentesene i listen over.
    </para>

    <para>
      For mer informasjon om stripping, se <ulink
      url="https://www.technovelty.org/linux/stripping-shared-libraries.html"/>.
    </para>

  </sect2>

<!--
  <sect2 id="libtool">
    <title>Libtool filer</title>

    <para>
      En av bivirkningene av pakker som bruker Autotools, inkludert
      libtool, er at de lager mange filer med en .la-utvidelse. Disse
      filer er ikke nødvendig i et LFS-miljø. Hvis det er konflikter med
      pkgconfig-oppføringer, kan de faktisk forhindre vellykkede bygg. Du
      vil kanskje vurdere å fjerne disse filene med jevne mellomrom:
    </para>

<screen><userinput>find /lib /usr/lib -not -path "*Image*" -a -name \*.la -delete</userinput></screen>

    <para>
      Kommandoen ovenfor fjerner alle .la-filer med unntak av de som
      har <quote>Image</quote> eller <quote>openldap</quote> som en del av
      stien. Disse .la-filene brukes av ImageMagick og openldap-programmene,
      hhv. Det kan være andre unntak for pakker som ikke er i BLFS.
    </para>

  </sect2>
-->
  <sect2 id="buildsystems">
    <title>Arbeide med ulike byggesystemer</title>

    <para>
      Det er nå tre forskjellige byggesystemer i vanlig bruk for
      å konvertere C eller C++ kildekode til kompilerte programmer eller
      biblioteker og deres detaljer (spesielt å finne ut om tilgjengelige
      alternativer og deres standardverdier) er forskjellige. Det er kanskje lettest å forstå
      problemene forårsaket av noen valg (vanligvis langsom utførelse eller
      uventet bruk av, eller utelatelse av, optimaliseringer) ved å starte med
      miljøvariablene CFLAGS og CXXFLAGS. Det er også noen
      programmer som bruker rust.
    </para>

    <para>
      De fleste LFS- og BLFS-byggere er sannsynligvis klar over det grunnleggende om CFLAGS
      og CXXFLAGS for å endre hvordan et program kompileres. Vanligvis noen
      form for optimalisering brukes av oppstrømsutviklere (-O2 eller -O3),
      noen ganger med opprettelse av feilsøkingssymboler (-g), som standard.
    </para>

    <para>
      Hvis det er motstridende flagg (f.eks. flere forskjellige -O-verdier),
      den <emphasis>siste</emphasis> verdien vil bli brukt. Noen ganger betyr dette
      at flagg spesifisert i miljøvariabler vil bli plukket opp før
      verdier hardkodet i Makefilen, og derfor ignorert. For eksempel,
      der en bruker spesifiserer '-O2' og det blir etterfulgt av '-O3' vil byggingen
      bruke '-O3'.
    </para>

    <para>
      Det er forskjellige andre ting som kan sendt til CFLAGS eller
      CXXFLAGS, for eksempel å tvinge kompilering for en spesifikk mikroarkitektur
      (f.eks. -march=amdfam10, -march=native) eller spesifisere en spesifikk standard
      for C eller C++ (-std=c++17 for eksempel). Men en ting som nå har kommet
      for bruk er at programmerere kan inkludere feilsøkingspåstander i sin
      kode, og forventer at de blir deaktivert i utgivelser ved å bruke -DNDEBUG.
      Spesielt hvis <xref linkend="mesa"/> er bygget med disse flaggene
      aktivert, kan enkelte aktiviteter som lasting av spill ta
      ekstremt lang tid, selv på skjermkort av høy klasse.
    </para>

    <bridgehead renderas="sect3" id="autotools-info">Autotools med Make</bridgehead>

      <para>
       Denne kombinasjonen beskrives ofte som 'CMMI' (konfigurere, bygg, bygg
       installere (configure, make, make install)) og brukes her til også å dekke de få pakkene som har et
       konfigureringsskript som ikke er generert av autoverktøy.
      </para>

      <para>
        Noen ganger å kjøre <command>./configure --help</command> vil produsere
        nyttige alternativer om brytere som kan brukes. Andre ganger,
        etter å ha sett på utdataene fra configure må du kanskje se
        på detaljene i skriptet for å finne ut hva det faktisk søkte
        etter.
      </para>

      <para>
       Mange konfigureringsskript vil plukke opp alle CFLAGS eller CXXFLAGS fra
       miljøet, men CMMI pakker varierer med hvordan disse vil bli blandet med
       flagg som ellers ville blitt brukt (<emphasis>forskjellig</emphasis>:
       ignorert, brukt til å erstatte programmererens forslag, brukt før
       programmerers forslag, eller brukt etter programmererens forslag).
      </para>

      <para>
       I de fleste CMMI pakkene vil kjøring av 'make' liste hver kommando og kjøre
       det, ispedd eventuelle advarsler. Men noen pakker prøver å være "stille"
       og bare vise hvilken fil de kompilerer eller kobler til i stedet for å vise
       kommandolinjen. Hvis du trenger å inspisere kommandoen, enten pga
       en feil, eller bare for å se hvilke alternativer og flagg som brukes, legg til
       'V=1' til make påkallelsen kan hjelpe.
     </para>

    <bridgehead renderas="sect3" id="cmake-info">CMake</bridgehead>

      <para>
        CMake fungerer på en helt annen måte, og den har to bakstykker som kan
        brukes på BLFS: 'make' og 'ninja'. Standard bakstykke er make, men
        ninja kan være raskere på store pakker med flere prosessorer. For
        å bruke ninja, spesifiser '-G Ninja' i cmake kommandoen. Det finnes imidlertid
        noen pakker som skaper fatale feil i ninja filene, men bygger
        vellykket ved å bruke standarden til Unix Makefiler.
      </para>

      <para>
        Den vanskeligste delen med å bruke CMake er å vite hvilke alternativer du måtte ønske
        å spesifisere. Den eneste måten å få en liste over hva pakken vet
        er å kjøre <command>cmake -LAH</command> og se på utdataen for
        standardkonfigurasjon.
      </para>

      <para>
        Det kanskje viktigste med CMake er at den har en variasjon
        av CMAKE_BUILD_TYPE verdier, og disse påvirker flaggene. Standaren
        er at dette ikke er satt og ingen flagg blir generert. Eventuelle CFLAGS eller
        CXXFLAGS i miljøet vil bli brukt. Hvis programmereren har kodet
        eventuelle feilsøkingspåstander, vil de bli aktivert med mindre -DNDEBUG brukes.
        Følgende CMAKE_BUILD_TYPE verdier vil generere flaggene som vises,
        og disse vil komme <emphasis>etter</emphasis> eventuelle flagg i
        miljøet og har derfor forrang.
      </para>

      <informaltable align="center">
        <tgroup cols="2">
          <colspec colnum="1" align="center"/>
          <colspec colnum="2" align="center"/>
          <thead>
            <row><entry>Verdi</entry><entry>Flagg</entry></row>
          </thead>
          <tbody>
            <row>
              <entry>Debug</entry><entry><option>-g</option></entry>
            </row>
            <row>
              <entry>Release</entry><entry><option>-O3 -DNDEBUG</option></entry>
            </row>
            <row>
              <entry>RelWithDebInfo</entry><entry><option>-O2 -g -DNDEBUG</option></entry>
            </row>
            <row>
              <entry>MinSizeRel</entry><entry><option>-Os -DNDEBUG</option></entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>

      <para>
        CMake prøver å produsere stille bygginger. For å se detaljene til kommandoene
        som kjøres, bruk <command>make VERBOSE=1</command> eller
        <command>ninja -v</command>.
      </para>

      <para>
        Som standard behandler CMake filinstallasjon annerledes enn andre
        byggesystemer: hvis en fil allerede eksisterer og ikke er nyere enn en fil
        som ville overskrive den, så blir ikke filen installert. Dette kan være
        et problem hvis en bruker ønsker å registrere hvilken fil som tilhører en pakke,
        enten ved hjelp av <envar>LD_PRELOAD</envar>, eller ved å liste nyere filer
        enn et tidsstempel. Standarden kan endres ved å angi variabelen
        <envar>CMAKE_INSTALL_ALWAYS</envar> til 1 i
        <emphasis>miljøet</emphasis>, for eksempel med
        <command>export</command>.
      </para>

    <bridgehead renderas="sect3" id="meson-info">Meson</bridgehead>

      <para>
        Meson har noen likheter med CMake, men mange forskjeller. Å få
        detaljer om definisjonene som du kanskje ønsker å endre kan du se på
        <filename>meson_options.txt</filename> som vanligvis er i
         mappen på øverste nivå.
      </para>

      <para>
        Hvis du allerede har konfigurert pakken ved å kjøre
        <command>meson</command> og nå ønsker å endre en eller flere innstillinger,
        kan du enten fjerne byggemappen, gjenskape den og bruke de
        endrede alternativene, eller kjøre i byggemappen <command>meson
        configure</command>, f.eks. for å angi et alternativ:
      </para>

<screen><userinput>meson configure -D&lt;noen_alternativ&gt;=true</userinput></screen>

      <para>
        Hvis du gjør det, filen <filename>meson-private/cmd_line.txt</filename>
        vil vise den <emphasis>siste</emphasis> kommandoer som ble brukt.
      </para>

      <para>
        Meson gir følgende byggetype verdier, og flaggene de aktiverer
        kommer <emphasis>etter</emphasis> eventuelle flagg som leveres i miljøet og
        har derfor forrang.
      </para>

      <itemizedlist>
        <listitem>
          <para>plain : ingen flagg lagt til. Dette er for distributører for å levere sine
          egne CLFAGS, CXXFLAGS og LDFLAGS. Det er ingen åpenbar grunn til å bruke
          dette i BLFS.</para>
        </listitem>
        <listitem>
          <para>debug : '-g' - dette er standard hvis ingenting er spesifisert
          i enten <filename>meson.build</filename> eller kommandolinjen.
          Men det resulterer i store og langsomme binærfiler, så vi bør overstyre
          det i BLFS.</para>
        </listitem>
        <listitem>
           <para>debugoptimized : '-O2 -g' : dette er standard spesifisert i
           <filename>meson.build</filename> av noen pakker.</para>
        </listitem>
        <listitem>
           <para>release : '-O3 -DNDEBUG' (men noen ganger vil en pakke tvinge
           -O2 her)</para>
        </listitem>
      </itemizedlist>

      <para>
        Selv om 'utgivelse' byggetypene er beskrevet som å aktivere -DNDEBUG, og alle
        CMake utgivelses byggene sender dette, det har så langt bare blitt observert (i
        detaljerte bygg) for <xref linkend="mesa"/>. Det tyder på at det kan
        brukes kun når det er feilsøkingspåstander.
      </para>

      <para>
        The -DNDEBUG flag kan også gis ved å sende
        <command>-Db_ndebug=true</command>.
      </para>

      <para>
        For å se detaljene for kommandoene som kjøres i en pakke ved hjelp av
        meson, bruk 'ninja -v'.
      </para>

    <bridgehead renderas="sect3" id="rust-info">Rustc og Cargo</bridgehead>

      <para>
        De fleste utgitte rustc programmer leveres som cargo (kilde tarballer)
        som vil spørre en server om å sjekke gjeldende versjoner av avhengigheter
        og last dem ned etter behov. Disse pakkene er bygges med
        <command>cargo --release</command>. I teorien kan du manipulere
        RUSTFLAGS for å endre optimaliseringsnivået (standard er 3, som -O3, f.eks.
        <literal>-Copt-level=3</literal>) eller å tvinge den til å bygge for
        maskinen den blir kompilert på, ved hjelp av
        <literal>-Ctarget-cpu=native</literal> men i praksis ser dette ut til å
        gjøre ingen vesentlig forskjell.
      </para>

      <para>
        Hvis du finner et interessant rustc program som kun leveres som
        utpakket kilde, bør du i det minste spesifisere
        <literal>RUSTFLAGS=-Copt-level=2</literal> ellers vil det gjøre en
        uoptimalisert kompilering med feilsøkingsinformasjon og kjøre <emphasis>mye</emphasis>
        saktere.
      </para>

      <para>
        Rustutviklerne ser ut til å anta at alle vil kompilere på en
        maskin dedikert til å produsere bygg, så som standard brukes alle CPUer.
        Dette kan ofte omgås, enten ved å eksportere
        CARGO_BUILD_JOBS=&lt;N&gt; eller sende --jobs &lt;N&gt; til cargo. For å
        kompilere rustc selv, spesifisere --jobs &lt;N&gt; på påkallelser av
        x.py (sammen med <envar>CARGO_BUILD_JOBS</envar> miljøvariabel,
        som ser ut som "parenteser", men ser ut til å være
        nødvendig) fungerer for det meste. Unntaket er å kjøre testene når du bygger
        rustc, vil noen av dem likevel bruke alle nettbaserte prosessorer, i hvert fall pr
        rustc-1.42.0.
      </para>

  </sect2>

  <sect2 id="optimizations">
    <title>Optimalisering av bygget</title>

      <para>
        Mange mennesker vil foretrekke å optimalisere kompileringer slik de finner passende, ved å tilby
        CFLAGS eller CXXFLAGS. For en introduksjon til alternativene som er tilgjengelige med gcc
        og g++ se <ulink
        url="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html"/> og <ulink
        url="https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html"/>
        og <command>info gcc</command>.

      </para>

      <para>
        Noen pakker er som standard '-O2 -g', andre '-O3 -g', og hvis CFLAGS eller
        CXXFLAGS leveres, kan de legges til pakkens standardinnstillinger,
        erstatte pakkens standardinnstillinger, eller til og med bli ignorert. Det er detaljer
        på noen skrivebordspakker som stort sett var aktuelle i april 2019 på
        <ulink url="https://www.linuxfromscratch.org/~ken/tuning/"/> - i
        spesielt, README.txt, tuning-1-packages-and-notes.txt, og
        tuning-notes-2B.txt. Det spesielle å huske er at hvis du
        ønsker å prøve noen av de mer interessante flaggene må du kanskje tvinge
        detaljerte bygg for å bekrefte hva som brukes.
      </para>

      <para>
        Klart, hvis du optimaliserer ditt eget program kan du bruke tid på det
        profilere det og kanskje omkode noe av det hvis det er for tregt. Men for
        å bygge et helt system er det upraktisk. Generelt,
        -O3 produserer vanligvis raskere programmer enn -O2. Spesifisere
        -march=native er også gunstig, men betyr at du ikke kan flytte
        binærfiler til en inkompatibel maskin - dette kan også gjelde for nyere
        maskiner, ikke bare eldre maskiner. For eksempel programmer kompilert for
        'amdfam10' kjører på gamle Phenoms, Kaveris og Ryzens: men programmer
        kompilert for en Kaveri vil ikke kjøre på en Ryzen fordi visse op koder
        ikke er tilstede. På samme måte, hvis du bygger for en Haswell, vil ikke alt
        kjøre på en SandyBridge.
      </para>

      <para>
        Det er også forskjellige andre alternativer som noen hevder er
        gunstige. I verste fall får du rekompilere og teste, og så
        oppdage at i din bruk gir alternativene ikke en fordel.
      </para>

      <para>
        Hvis du bygger Perl- eller Python-moduler, eller Qtpakker som bruker qmake,
        generelt er CFLAGS og CXXFLAGS som brukes de som ble brukt av
        disses 'foreldre'-pakker.
      </para>

  </sect2>

  <sect2 id="hardening">
    <title>Alternativer for sikring av bygget</title>

      <para>
        Selv på stasjonære systemer er det fortsatt mye som kan utnytte
        sårbarheter. For mange av disse kommer angrepet via javascript
        i en nettleser. Ofte brukes en rekke sårbarheter for å få
        tilgang til data (eller noen ganger til pwn, dvs. eie, maskinen og
        installer rootkits). De fleste kommersielle distros vil bruke ulike
        sikringstiltak.
      </para>

      <para>
        Tidligere var det Hardened LFS der gcc (en mye eldre versjon)
         ble tvunget til å bruke herding (med alternativer for å slå av noe av det på en
         per pakke-basis). De nåværende LFS- og BLFS-bøkene fører
         videre en del av sin ånd ved å aktivere PIE
        (<option>-fPIE -pie</option>) og SSP
        (<option>-fstack-protector-strong</option>) som standard
        for GCC og clang. Det som dekkes her er annerledes - for det første
        må du forsikre deg om at pakken faktisk bruker flaggene du har lagt til
        og ikke overstyre dem.
      </para>

      <para>
        For herdealternativer som er rimelig billige, finnes det noen
        diskusjon i "tuning" lenken ovenfor (noen ganger kan en eller flere
        av disse alternativene være upassende for en pakke). Disse
        alternativene er <option>-D_FORTIFY_SOURCE=2</option> og
        (for C++) <option>-D_GLIBCXX_ASSERTIONS</option>. På moderne
        maskiner skal disse bare ha en liten innvirkning på hvor raskt ting
        kjører, og ofte vil de ikke merkes.
      </para>

      <para>
        De viktigste distroene bruker mye mer, for eksempel RELRO (Relocation Read Only)
        og kanskje <option>-fstack-clash-protection</option>. Du kan også
        møte den såkalte <quote>userspace retpoline</quote>
        (<option>-mindirect-branch=thunk</option> etc.) hvilken
        tilsvarer spekter begrensninger som ble tatt i bruk i linux
        kjernen sent i 2018. Kjernebegrensningene forårsaket mange klager
        om tapt ytelse, hvis du har en produksjonsserver ønsker du kanskje
         å vurdere å teste det, sammen med de andre tilgjengelige alternativene, å
         se om ytelsen fortsatt er tilstrekkelig.
      </para>

      <para>
        Mens gcc har mange herdealternativer, ligger clang/LLVMs styrke
        andre steder. Noen alternativer som gcc tilbyr sies å være mindre effektive
        i clang/LLVM.
      </para>

  </sect2>

</sect1>
